package scalaz.stream.mongodb.filesystem

import org.specs2.{ScalaCheck, Specification}
import org.specs2.specification.Snippets

import scalaz.stream.mongodb.collectionSyntax._
import scalaz.stream.mongodb.MongoRuntimeSpecification
import org.specs2.matcher.MatchResult
import org.scalacheck.{Gen, Arbitrary}
import com.mongodb.gridfs.GridFS
import org.bson.types.ObjectId

import scala.language.reflectiveCalls
import scalaz.stream.mongodb.channel.ChannelResult


class FSListSpec extends Specification with Snippets with MongoRuntimeSpecification with ScalaCheck {

  lazy val fileId: ObjectId = ???

  def is =
    s2"""
    
${"Listing files in filesystem".title}
      
       
### Basic lists
 
To list files named with given name use `named` syntax:
 
${ snippet { list named ("file1") }}    $listNamed
       

Concrete files can be queried by specifying their `id` :
       
${ snippet { list withId (fileId) }}    $listId       
       

### Complex queries
       
Each mongodb file stores metadata that can content basically everything as normal bson document. However there
are some specific properties that are included in this document: 

* _id            contains unique identification of file that is either supplied when writing to document or generated by driver
* filename       filename of the document, this may not be unique, 
* contentType    MIME type of the file, may be null
* length         size of the file in bytes
* chunkSize      size of the file `chunk`. File is chunked in database and then reassembled on read
* uploadDate     date when the file was uploaded to the db
* aliases        aliases of the file (array of strings)
* md5            MD5 hash of file content
* metadata       Object holding metadata for the file collection

Metadata are thus residing in `metadata` key, and anything that has to be queried in metadata must be prefixed by `metadata`. 
Following are the examples of complex file queries : 

* Where file name contains character `a`:    ${ snippet { list files ("filename" regex ".*a.*") } }   ${filesTest.namedA}
* Where file MIME type is `text/plain; charset=UTF-8` : ${ snippet { list files ("contentType" === "text/plain; charset=UTF-8") } }  ${filesTest.listFileMime}
* Where metadata key `user` is `luke`: ${ snippet { list files ("metadata.user" === "luke") } }  ${filesTest.listMeta}     
 

### Combining result of listing the files

The individual listing of the files can be combined together to make different queries, even from different filesystems
via `append` (or `++`) combinator.

${ snippet {

      val allFiles = (list named ("alpha")) ++
        (list named ("beta")) ++
        (list files ("filename" regex "g.*"))

    }} ${filesTest.listCompose}
   
       
### Sorting the listing of the files

       ${todo}
      
    """

  def is2 = filesTest.listCompose

  def listNamed = {
    FileSystemCommand(
      list named "gamma"
    ).verify({
      case read if read.size == 1 && read.head.name == "gamma" => ok
      case other => ko
    }) and FileSystemCommand(
      list named "---"
    ).verify({
      case Seq() => ok
      case other => ko
    })
  }

  def listId = FileSystemCommand(
    list withId defaultFiles(3).id
  ).verify({
    case read if read.size == 1 && read.head.name == "delta" => ok
    case other => ko
  }) and FileSystemCommand(
    list withId (new ObjectId())
  ).verify({
    case Seq() => ok
    case other => ko
  })

  def filesQuery(fsCommand: ListCommand, expected: Seq[MongoFileWrite]) = {
    FileSystemCommand(fsCommand).verify(got => got.map(_.id) must haveTheSameElementsAs(expected.map(_.id)))
  }


  def filesTest = new {
    def namedA = filesQuery(list.files("filename" regex ".*a.*"), defaultFiles.init)

    def listFileMime = filesQuery(list files ("contentType" === "text/plain; charset=UTF-8"), Seq(defaultFiles(1)))

    def listMeta = filesQuery(list files ("metadata.user" === "luke"), Seq(defaultFiles(2)))


    def listCompose = FileSystemCommand(
      (list named ("alpha")) ++
        (list named ("beta")) ++
        (list files ("filename" regex "g.*"))
    ).verify(result =>
      result.map(_.id) must haveTheSameElementsAs(Seq(defaultFiles(0), defaultFiles(1), defaultFiles(2)).map(_.id))
                      )

  }


  ///////////////////////////////////////////////////////////////////////////////////////////
  // SUPPORT
  ///////////////////////////////////////////////////////////////////////////////////////////

  implicit val fileNameArbitrary = Arbitrary(Gen.alphaStr)

  val defaultFiles = List(
    file("alpha")
    , file("beta", contentType = Some("text/plain; charset=UTF-8"))
    , file("gamma", meta = Some(BSONObject("user" -> "luke")))
    , file("delta")
    , file("epsilon")
  )

  case class FileSystemCommand(fsCommand: ChannelResult[GridFS,MongoFileRead]
                               , files: Seq[MongoFileWrite] = defaultFiles) {

    val mongo = new WithMongoCollection()

    def verify(f: Seq[MongoFileRead] => MatchResult[Any]) = {
      val fs = new GridFS(mongo.db)
      files.foreach {
        wf =>
          val file =
            fs.createFile(Array[Byte](1))

          file.setFilename(wf.name)
          file.setId(wf.id)
          wf.contentType.foreach(file.setContentType(_))
          wf.userMeta.foreach(file.setMetaData(_))
          file.save()
      }

      f((filesystem(mongo.db) through fsCommand).runLog.run)

    }
  }


}
