package scalaz.stream.mongodb.filesystem

import org.specs2.{ScalaCheck, Specification}
import org.specs2.specification.Snippets

import scalaz.stream.mongodb.collectionSyntax._
import scalaz.stream.mongodb.MongoRuntimeSpecification
import org.specs2.matcher.MatchResult
import org.scalacheck.{Gen, Arbitrary}
import com.mongodb.gridfs.GridFS
import scalaz.stream.mongodb.channel.ChannelResult
import com.mongodb.DB
import org.bson.types.ObjectId

import scala.language.reflectiveCalls

/**
 *
 * User: pach
 * Date: 9/22/13
 * Time: 7:58 AM
 * (c) 2011-2013 Spinoco Czech Republic, a.s.
 */
class FSListSpec extends Specification with Snippets with MongoRuntimeSpecification with ScalaCheck {

  lazy val fileId: ObjectId = ???

  def is =
    s2"""
    
      ${"Listing files in filesystem".title}
      
       
### Basic lists
 
To list files named with given name use `named` syntax:
 
${ snippet { filesystem() list named("file1") }}    $listNamed
       

Concrete files can be queried by specifying their `id` :
       
${ snippet { filesystem() list withId(fileId) }}    $listId       
       

### Complex queries
       
Each mongodb file stores metadata that can content basically everything as normal bson document. However there
are some specific properties that are included in this document: 

* _id            contains unique identification of file that is either supplied when writing to document or generated by driver
* filename       filename of the document, this may not be unique, 
* contentType    MIME type of the file, may be null
* length         size of the file in bytes
* chunkSize      size of the file `chunk`. File is chunked in database and then reassembled on read
* uploadDate     date when the file was uploaded to the db
* aliases        aliases of the file (array of strings)
* md5            MD5 hash of file content
* metadata       Object holding metadata for the file collection

Metadata are thus residing in `metadata` key, and anything that has to be queried in metadata must be prefixed by `metadata`. 
Following are the examples of complex file queries : 

* Where file name contains character `a`:    ${ snippet { filesystem() list files("filename" regex ".*a.*") } }   ${filesTest.namedA}
* Where file MIME type is `text/plain; charset=UTF-8` : ${ snippet { filesystem() list files("contentType" === "text/plain; charset=UTF-8") } }  ${filesTest.listFileMime}
* Where metadata key `user` is `luke`: ${ snippet { filesystem() list files("metadata.user" === "luke") } }  ${filesTest.listMeta}     
 

### Combining result of listing the files

The individual listing of the files can be combined together to make different queries, even from different filesystems
via `append` (or `++`) combinator.

${ snippet {
    
      val allFiles = (filesystem() list named("alpha")) ++ 
        (filesystem() list named("beta")) ++
        (filesystem() list files("filename" regex "g.*")) 

    }} ${filesTest.listCompose}
        
      
    """

  def is2 = filesTest.listCompose

  def listNamed = {
    FileSystemCommand(
      filesystem() list named("gamma")
    ).verify({
      case read if read.size == 1 && read.head.name == "gamma" => ok
      case other => ko
    }) and FileSystemCommand(
      filesystem() list named("---")
    ).verify({
      case Seq() => ok
      case other => ko
    })
  }

  def listId = FileSystemCommand(
    filesystem() list withId(defaultFiles(3).id)
  ).verify({
    case read if read.size == 1 && read.head.name == "delta" => ok
    case other => ko
  }) and FileSystemCommand(
    filesystem() list withId(new ObjectId())
  ).verify({
    case Seq() => ok
    case other => ko
  })

  def filesQuery(fq: FileQuery, expected: Seq[MongoFileWrite]) = {
    FileSystemCommand(filesystem() list fq).verify(got => got.map(_.id) must haveTheSameElementsAs(expected.map(_.id)))
  }

  
  def filesTest = new  {
    def namedA = filesQuery(files("filename" regex ".*a.*"), defaultFiles.init)
    
    def listFileMime =  filesQuery(files("contentType" === "text/plain; charset=UTF-8"), Seq(defaultFiles(1)))
    
    def listMeta =  filesQuery(files("metadata.user" === "luke"), Seq(defaultFiles(2)))
    
    def listCompose = FileSystemCommand(
      (filesystem() list named("alpha")) ++
      (filesystem() list named("beta")) ++
      (filesystem() list files("filename" regex "g.*"))
    ).verify( result =>
      result.map(_.id) must haveTheSameElementsAs(Seq(defaultFiles(0), defaultFiles(1), defaultFiles(2)).map(_.id) )
    )
    
  } 
  

  ///////////////////////////////////////////////////////////////////////////////////////////
  // SUPPORT
  ///////////////////////////////////////////////////////////////////////////////////////////

  implicit val fileNameArbitrary = Arbitrary(Gen.alphaStr)

  val defaultFiles = List(
    file("alpha")
    , file("beta", contentType = Some("text/plain; charset=UTF-8"))
    , file("gamma", meta = Some(BSONObject("user" -> "luke")))
    , file("delta")
    , file("epsilon")
  )

  case class FileSystemCommand(query: ChannelResult[DB, MongoFileRead]
                               , files: Seq[MongoFileWrite] = defaultFiles) {

    val mongo = new WithMongoCollection()

    def verify(f: Seq[MongoFileRead] => MatchResult[Any]) = {
      val fs = new GridFS(mongo.db)
      files.foreach {
        wf =>
          val file =
            fs.createFile(Array[Byte](1))

          file.setFilename(wf.name)
          file.setId(wf.id)
          wf.contentType.foreach(file.setContentType(_))
          wf.userMeta.foreach(file.setMetaData(_))
          file.save()
      }

      f((mongo.db through query).collect.run)

    }
  }


}
